package ax.makila.comparableentititymining;

import java.util.ArrayList;
import java.util.HashSet;
import java.util.List;
import java.util.Set;

import ax.makila.comparableentititymining.postagger.CompTaggedWord;
import ax.makila.comparableentititymining.sequentialpatterns.Sequence;
import ax.makila.comparableentititymining.sequentialpatterns.SequentialPattern;
import ax.makila.comparableentititymining.sequentialpatterns.patterns.GeneralizedSequence;
import ax.makila.comparableentititymining.sequentialpatterns.patterns.LexicalSequence;
import ax.makila.comparableentititymining.sequentialpatterns.patterns.SpecializedSequence;

import com.abahgat.suffixtree.GeneralizedSuffixTree;

import edu.stanford.nlp.process.PTBTokenizer;

@SuppressWarnings("unused")
public class PatternGeneration {
	private static String comparator = MiningIndicativeExtractionPatterns.comparator;
	private static int beta = MiningIndicativeExtractionPatterns.beta;

	public static List<String> mineGoodPatterns(
			List<String> seedComparatorPairs,
			List<Sequence> comparativeQuestionSet) {

		for (Sequence question : comparativeQuestionSet) {
			/*
			 * String surfacePattern = surfaceTextPatternMining(question)
			 */
		}
		Set<SequentialPattern> lexicalPatterns = generateLexicalPatterns(comparativeQuestionSet);
		System.out.println(lexicalPatterns.size());
		Set<SequentialPattern> generalizedPatterns = generateGeneralizedPatterns(lexicalPatterns);
		System.out.println(generalizedPatterns.size());
		Set<SequentialPattern> specializedPatterns = generateSpecializedPatterns(
				lexicalPatterns, generalizedPatterns);
		System.out.println(specializedPatterns.size());

		//Do some fancy pattern eval
		return null;
	}

	/**
	 * Lexical patterns indicate sequential patterns consisting of only words
	 * and symbols ($C, #start, and "#end"). They are generated by suffix tree
	 * algorithm with two constraints: A patterns should contain more than one
	 * $C and its frequency in collection should be more than an empirically
	 * determined number beta.
	 * 
	 * @param questions
	 *            The set of questions to generate patterns from
	 * @return A set of lexical patterns
	 */
	public static Set<SequentialPattern> generateLexicalPatterns(List<Sequence> questions) {
		Set<SequentialPattern> lexicalPatterns = new HashSet<SequentialPattern>();
		GeneralizedSuffixTree tree = new GeneralizedSuffixTree();
		String regex = "(^|.*?\\s)\\$c.*?\\s\\$c[^A-Za-z0-9_$].*?$";
		//Add all suffixes to the 
		int index = 0;
		for(Sequence seq : questions) {
			List<String> internal = seq.getSequence();
			for(int i = 0; i < internal.size(); i++) {
				tree.put(internal.get(i), index);
				index++;
			}
		}
		Set<String> candidatePatterns = tree.searchMatchingSuffix(regex);
		// Patterns are only kept if their frequency in the collection is more
		// than an empirically determined number beta
		for(String candidate : candidatePatterns) {
			if(isFrequent(candidate, questions, beta)) {
				LexicalSequence lex = new LexicalSequence(candidate);
				lexicalPatterns.add(lex);
			}
		}
		return lexicalPatterns; 
	}

	/**
	 * A pattern is only kept if it's frequency in the collection <tt>questionSet</tt>
	 * exceeds a threshold limit <tt>beta</tt>. 
	 * @param pattern The pattern that will be checked with its frequency 
	 * @param questionSet The set of questions that the pattern will match against
	 * @param beta The threshold frequency for the pattern
	 * @return true if the pattern exceeds the threshold, else false.
	 */
	private static boolean isFrequent(String pattern, List<Sequence> questionSet, int beta) {
		int counter = 0;
		for(Sequence question : questionSet) {
			if(question.text().endsWith(pattern)) {
				counter++;
			}
		}
		return counter > beta;
	}

	/**
	 * A lexical pattern can be too specific. Thus, we generalize lexical
	 * patterns by replacing one or more words/phrases with their POS tags.
	 * 2^(n-1) generalized patterns can be produced from a lexical pattern
	 * containing N words excluding $Cs.
	 * 
	 * @param lexPatterns
	 *            A lexical pattern from which generalized patterns can be
	 *            generated
	 * @return A set of generalized patterns
	 */
	public static Set<SequentialPattern> generateGeneralizedPatterns(
			Set<SequentialPattern> lexPatterns) {
		System.out.println("Lexical pattern size = " + lexPatterns.size());
		Set<SequentialPattern> generalizedPatterns = new HashSet<SequentialPattern>();
		for(SequentialPattern sequence : lexPatterns) {
			List<List<CompTaggedWord>> taggedSequence = sequence.getTaggedWords();
			for(List<CompTaggedWord> comp : taggedSequence) {
				System.out.println("Sequence length = " + comp.size());
				//Checks if the string starts or ends with #start or #end
				int start = 0;
				int end = 0;
				if(comp.get(0).tag().equals("#")) {
					start = 1;
				}
				else if(comp.get(taggedSequence.size() - 1).tag().equals("#")) {
					end = 1;
				}
				//Sets a max limit to reduce the processing time
				int numBits = Math.min(taggedSequence.size(), 12);
				int max = (int) Math.pow(2, numBits - start - 1);
				for(int i = 1 + start; i <= max; i += 1 + end) {
					String format = "%" + numBits + "s";
					String bin = String.format(format, Integer.toBinaryString(i))
							.replace(' ', '0');
					char[] binary = bin.toCharArray();
					//A 1 in the binary array tells us that the word in that location
					//in the sequence should be replaced by its pos tag
					StringBuilder sb = new StringBuilder();
					for(int j = 0; j < binary.length; j++) {
						CompTaggedWord replace = comp.get(j);
						if(binary[j] == '1') {
							//Ignore comparators
							if(!replace.value().equals("$c")) {
								sb.append(replace.tag());
							}
							else {
								sb.append(replace.value());
							}
							sb.append(" ");
						}
					}
					String s = PTBTokenizer.ptb2Text(sb.toString());
					SequentialPattern seqPattern = new GeneralizedSequence(s);
					generalizedPatterns.add(seqPattern);
				}
			}
		}
		return generalizedPatterns;
	}

	/**
	 * In some cases, a pattern can be too general. For example, although, a
	 * question "ipod or zune" is comparative, the pattern "<$C or $C> is too
	 * general, and there can be many noncomparative questions matching the
	 * pattern, for instance "true or false?". Fir this reason, we perform
	 * pattern specialization by adding POS tags to all comparator slots. For
	 * example, from the lexical pattern, "<$C or $C>" and the question "ipod or
	 * zune", "<$C/NN or $C/NN> will be produced as a specialized pattern.
	 * 
	 * @param lexicalPatterns
	 *            The lexical patterns to be specialized
	 * @param generalPatterns
	 *            The general patterns to be generalized
	 * @return A set of specialized items generated from lexical and general
	 *         patterns.
	 */
	public static Set<SequentialPattern> generateSpecializedPatterns(
			Set<SequentialPattern> lexicalPatterns, Set<SequentialPattern> generalPatterns) {
		List<SequentialPattern> combinedPatterns = new ArrayList<SequentialPattern>(lexicalPatterns);
		combinedPatterns.addAll(generalPatterns);
		Set<SequentialPattern> specializedPatterns = new HashSet<SequentialPattern>();
		for (int i = 0; i < combinedPatterns.size(); i++) {
			SequentialPattern pattern = combinedPatterns.get(i);
			List<List<CompTaggedWord>> tokens = pattern.getTaggedWords();
			for(List<CompTaggedWord> list : tokens) {
				StringBuilder sb = new StringBuilder();
				for(CompTaggedWord tag : list) {
					if(tag.value().contains("$c")) {
						sb.append(tag.tag());
					}
					else {
						sb.append(tag.value());
					}
					sb.append(" ");
				}
				String sequence = PTBTokenizer.ptb2Text(sb.toString());
				SequentialPattern seq = new SpecializedSequence(sequence);
				specializedPatterns.add(seq);
			}
		}
		return specializedPatterns;
	}

}