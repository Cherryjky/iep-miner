package ax.makila.comparableentititymining;

import java.util.ArrayList;
import java.util.HashSet;
import java.util.List;
import java.util.Set;

import ax.makila.comparableentititymining.postagger.CompTaggedWord;
import ax.makila.comparableentititymining.sequentialpatterns.Sequence;
import ax.makila.comparableentititymining.sequentialpatterns.SequentialPattern;
import ax.makila.comparableentititymining.sequentialpatterns.patterns.GeneralizedSequence;
import ax.makila.comparableentititymining.sequentialpatterns.patterns.LexicalSequence;
import ax.makila.comparableentititymining.sequentialpatterns.patterns.SpecializedSequence;

import com.abahgat.suffixtree.GeneralizedSuffixTree;

import edu.stanford.nlp.process.PTBTokenizer;

@SuppressWarnings("unused")
public class PatternGeneration {
	public static class Percent {
		double percent;
		int counter = 0;
		int total;
		boolean proceed = true;

		public Percent(int total) {
			this.total = total;
		}

		public void increment() {
			counter++;
			percent = counter/total;
		}

		public double percent() {
			return percent;
		}

		public boolean proceed() {
			return proceed;
		}

		public void stop() {
			proceed = false;
		}

	}
	private static String comparator = MiningIndicativeExtractionPatterns.comparator;

	//TODO: Use the real value for beta. This is just for testing
	private static int beta = 0;//MiningIndicativeExtractionPatterns.beta;

	/**
	 * A lexical pattern can be too specific. Thus, we generalize lexical
	 * patterns by replacing one or more words/phrases with their POS tags.
	 * 2^(n-1) generalized patterns can be produced from a lexical pattern
	 * containing N words excluding $Cs.
	 * 
	 * @param lexPatterns
	 *            A lexical pattern from which generalized patterns can be
	 *            generated
	 * @return A set of generalized patterns
	 */
	public static Set<SequentialPattern> generateGeneralizedPatterns(
			Set<SequentialPattern> lexPatterns) {
		Set<SequentialPattern> generalizedPatterns = new HashSet<SequentialPattern>();
		for(SequentialPattern sequence : lexPatterns) {
			List<List<CompTaggedWord>> list = sequence.getTaggedWords();
			List<CompTaggedWord> comp = new ArrayList<CompTaggedWord>();
			for(List<CompTaggedWord> innerList : list) {
				comp.addAll(innerList);
			}
			//Checks if the string starts or ends with #start or #end
			int start = 0;
			int end = 0;
			if(comp.get(0).tag().equals("#")) {
				start = 1;
			}
			if(comp.get(comp.size() - 1).tag().equals("#")) {
				end = 1;
			}
			//Sets a max limit to reduce the processing time
			int numBits = Math.min(comp.size(), 12);
			int max = (int) Math.pow(2, numBits - start - 1);
			for(int i = 1 + end; i <= max; i += 1 + end) {
				String format = "%" + numBits + "s";
				String bin = String.format(format, Integer.toBinaryString(i))
						.replace(' ', '0');
				char[] binary = bin.toCharArray();
				//A 1 in the binary array tells us that the word in that location
				//in the sequence should be replaced by its pos tag
				StringBuilder sb = new StringBuilder();
				for(int j = 0; j < binary.length; j++) {
					CompTaggedWord replace = comp.get(j);
					if(binary[j] == '1') {
						//Ignore comparators
						if(!replace.value().equals("$c")) {
							sb.append(replace.toString());
						}
						else {
							sb.append(replace.value());
						}
						sb.append(" ");
					}
					else {
						sb.append(replace.value());
						sb.append(" ");
					}
				}
				String s = PTBTokenizer.ptb2Text(sb.toString());
				SequentialPattern seqPattern = new GeneralizedSequence(s);
				generalizedPatterns.add(seqPattern);
			}

		}
		return generalizedPatterns;
	}

	/**
	 * Lexical patterns indicate sequential patterns consisting of only words
	 * and symbols ($C, #start, and "#end"). They are generated by suffix tree
	 * algorithm with two constraints: A patterns should contain more than one
	 * $C and its frequency in collection should be more than an empirically
	 * determined number beta.
	 * 
	 * @param questions
	 *            The set of questions to generate patterns from
	 * @return A set of lexical patterns
	 */
	public static Set<SequentialPattern> generateLexicalPatterns(Set<Sequence> questions) {
		Set<SequentialPattern> lexicalPatterns = new HashSet<SequentialPattern>();
		GeneralizedSuffixTree tree = new GeneralizedSuffixTree();
		String regex = "(^|.*?\\s)\\$c.*?\\s\\$c[^A-Za-z0-9_$].*?$";
		//Add all suffixes to the
		int index = 0;
		for(Sequence seq : questions) {
			List<String> internal = seq.getReplacedComparatorSequence();
			for(int i = 0; i < internal.size(); i++) {
				tree.put(internal.get(i), index);
				index++;
			}
		}
		Set<String> candidatePatterns = tree.searchMatchingSuffix(regex);
		// Patterns are only kept if their frequency in the collection is more
		// than an empirically determined number beta
		for(String candidate : candidatePatterns) {
			SequentialPattern lex = new LexicalSequence(candidate);
			//Iterates through and creates twice as many patterns but with the #end tag removed to be able
			//to match middle of sentence
			String mod = candidate.replace(" #end", "");
			SequentialPattern lex1 = new LexicalSequence(mod);
			if(isFrequent(lex, questions, beta)) {
				lexicalPatterns.add(lex);
			}
			if(isFrequent(lex1, questions, beta)) {
				lexicalPatterns.add(lex1);
			}
		}
		return lexicalPatterns;
	}

	/**
	 * In some cases, a pattern can be too general. For example, although, a
	 * question "ipod or zune" is comparative, the pattern "<$C or $C> is too
	 * general, and there can be many noncomparative questions matching the
	 * pattern, for instance "true or false?". Fir this reason, we perform
	 * pattern specialization by adding POS tags to all comparator slots. For
	 * example, from the lexical pattern, "<$C or $C>" and the question "ipod or
	 * zune", "<$C/NN or $C/NN> will be produced as a specialized pattern.
	 * 
	 * @param lexicalPatterns
	 *            The lexical patterns to be specialized
	 * @param generalPatterns
	 *            The general patterns to be generalized
	 * @return A set of specialized items generated from lexical and general
	 *         patterns.
	 */
	public static Set<SequentialPattern> generateSpecializedPatterns(
			Set<SequentialPattern> lexicalPatterns, Set<SequentialPattern> generalPatterns) {
		String regex = "(^|.*?\\s)\\$c.*?\\s\\$c[^A-Za-z0-9_$].*?$";
		List<SequentialPattern> combinedPatterns = new ArrayList<SequentialPattern>(lexicalPatterns);
		combinedPatterns.addAll(generalPatterns);
		Set<SequentialPattern> specializedPatterns = new HashSet<SequentialPattern>();
		for (int i = 0; i < combinedPatterns.size(); i++) {
			SequentialPattern pattern = combinedPatterns.get(i);
			List<List<CompTaggedWord>> tokens = pattern.getTaggedWords();
			List<CompTaggedWord> list = new ArrayList<CompTaggedWord>();
			for(List<CompTaggedWord> innerList : tokens) {
				list.addAll(innerList);
			}
			if(list.toString().matches(regex)) {
				StringBuilder sb = new StringBuilder();
				for(CompTaggedWord tag : list) {
					if(tag.value().equals("$c")) {
						sb.append(tag.toString());
					}
					else {
						sb.append(tag.value());
					}
					sb.append(" ");
				}
				String sequence = PTBTokenizer.ptb2Text(sb.toString());
				SequentialPattern seq = new SpecializedSequence(sequence);
				specializedPatterns.add(seq);
			}

		}
		return specializedPatterns;
	}

	/**
	 * A pattern is only kept if it's frequency in the collection <tt>questionSet</tt>
	 * exceeds a threshold limit <tt>beta</tt>.
	 * @param pattern The pattern that will be checked with its frequency
	 * @param questionSet The set of questions that the pattern will match against
	 * @param beta The threshold frequency for the pattern
	 * @return true if the pattern exceeds the threshold, else false.
	 */
	private static boolean isFrequent(SequentialPattern pattern, Set<Sequence> questionSet, int beta) {
		int counter = 0;
		for(Sequence question : questionSet) {
			if(question.matches(pattern)) {
				counter++;
			}
		}
		return counter > beta;
	}

	public static Set<SequentialPattern> mineGoodPatterns(
			Set<Pair<CompTaggedWord, CompTaggedWord>> pairs,
			Set<Sequence> comparativeQuestionSet,
			Set<SequentialPattern> newPatterns) {

		Set<SequentialPattern> reliableIEPs = new HashSet<SequentialPattern>();

		Set<SequentialPattern> lexicalPatterns = generateLexicalPatterns(comparativeQuestionSet);
		System.out.println("No. of lexical patterns: " + lexicalPatterns.size());

		Set<SequentialPattern> generalizedPatterns = generateGeneralizedPatterns(lexicalPatterns);
		System.out.println("No. of generalized patterns: " + generalizedPatterns.size());
		Set<SequentialPattern> specializedPatterns = generateSpecializedPatterns(
				lexicalPatterns, generalizedPatterns);
		System.out.println("No. of specialized patterns: " + specializedPatterns.size());

		Set<SequentialPattern> allPatterns = new HashSet<SequentialPattern>(lexicalPatterns);
		allPatterns.addAll(generalizedPatterns);
		allPatterns.addAll(specializedPatterns);
		System.out.println("Total no. of patterns " + allPatterns.size());

		for(SequentialPattern pattern : allPatterns) {
			//PatternEvaluation eval = new PatternEvaluation(pairs, pattern, comparativeQuestionSet);
			//if(eval.isReliable()) {
			//System.out.println("RELIABLE!");
			if(!newPatterns.contains(pattern)) {
				reliableIEPs.add(pattern);
			}
			//}
		}
		//Do some fancy pattern eval
		return reliableIEPs;
	}
}
