package ax.makila.comparableentititymining;

import java.util.ArrayList;
import java.util.HashSet;
import java.util.List;
import java.util.Set;

import ax.makila.comparableentititymining.postagger.CompTaggedWord;
import ax.makila.comparableentititymining.sequentialpatterns.Sequence;
import ax.makila.comparableentititymining.sequentialpatterns.SequentialPattern;
import ax.makila.comparableentititymining.sequentialpatterns.patterns.GeneralizedSequence;
import ax.makila.comparableentititymining.sequentialpatterns.patterns.LexicalSequence;
import ax.makila.comparableentititymining.sequentialpatterns.patterns.SpecializedSequence;

import com.abahgat.suffixtree.GeneralizedSuffixTree;

import edu.stanford.nlp.process.PTBTokenizer;
import edu.stanford.nlp.util.Timing;

/**
 * Class for generating and evaluating lexical, generalized and specialized patterns.
 * @author fredrik
 *
 */
public class PatternGeneration {
	/**
	 * Threshold parameter for the frequency of a lexical pattern
	 */
	public static final int beta = 10;


	/**
	 * A lexical pattern can be too specific. Thus, we generalize lexical
	 * patterns by replacing one or more words/phrases with their POS tags.
	 * 2^(n-1) generalized patterns can be produced from a lexical pattern
	 * containing n words excluding $Cs.
	 * 
	 * @param lexPatterns
	 *            A set of lexical pattern from which generalized patterns can be
	 *            generated
	 * @return A set of generalized patterns
	 */
	public static Set<SequentialPattern> generateGeneralizedPatterns(
			Set<SequentialPattern> lexPatterns) {
		Set<SequentialPattern> generalizedPatterns = new HashSet<SequentialPattern>();
		double total = lexPatterns.size();
		int steps = (int) total/10;
		double counter = 0;
		for(SequentialPattern sequence : lexPatterns) {
			if(counter % steps == 0 || counter == total - 1) {
				int percent = (int) (counter/(total-1)*100);
				System.out.print(percent + "% ");
			}
			counter++;
			List<List<CompTaggedWord>> list = sequence.getTaggedWords();
			List<CompTaggedWord> comp = new ArrayList<CompTaggedWord>();
			for(List<CompTaggedWord> innerList : list) {
				comp.addAll(innerList);
			}
			//Checks if the string starts or ends with #start or #end
			int start = 0;
			int end = 0;
			if(comp.get(0).tag().equals("#")) {
				start = 1;
			}
			if(comp.get(comp.size() - 1).tag().equals("#")) {
				end = 1;
			}
			//Sets a max limit to reduce the processing time
			int numBits = Math.min(comp.size(), 12);
			int max = (int) Math.pow(2, numBits - start - 1);
			for(int i = 1 + end; i <= max; i += 1 + end) {
				String format = "%" + numBits + "s";
				String bin = String.format(format, Integer.toBinaryString(i))
						.replace(' ', '0');
				char[] binary = bin.toCharArray();
				//A 1 in the binary array tells us that the word in that location
				//in the sequence should be replaced by its pos tag
				StringBuilder sb = new StringBuilder();
				for(int j = 0; j < binary.length; j++) {
					CompTaggedWord replace = comp.get(j);
					if(binary[j] == '1') {
						//Ignore comparators
						if(!replace.value().equals("$c")) {
							sb.append(replace.toString());
						}
						else {
							sb.append(replace.value());
						}
						sb.append(" ");
					}
					else {
						sb.append(replace.value());
						sb.append(" ");
					}
				}
				String s = PTBTokenizer.ptb2Text(sb.toString());
				SequentialPattern seqPattern = new GeneralizedSequence(s);
				generalizedPatterns.add(seqPattern);
			}

		}
		return generalizedPatterns;
	}

	/**
	 * Lexical patterns indicate sequential patterns consisting of only words
	 * and symbols ($C, #start, and "#end"). They are generated by suffix tree
	 * algorithm with two constraints: A patterns should contain more than one
	 * $C and its frequency in collection should be more than an empirically
	 * determined number {@value #beta}.
	 * 
	 * @param questions
	 *            The set of questions to generate patterns from
	 * @return A set of lexical patterns
	 */
	public static Set<SequentialPattern> generateLexicalPatterns(Set<Sequence> questions) {
		Set<SequentialPattern> lexicalPatterns = new HashSet<SequentialPattern>();
		GeneralizedSuffixTree tree = new GeneralizedSuffixTree();
		String regex = "(^|.*?\\s)\\$c.*?\\s\\$c[^A-Za-z0-9_$].*?$";
		//Add all suffixes to the

		int index = 0;
		for(Sequence seq : questions) {
			if(seq.hasReplacedComparators()) {
				List<String> internal = seq.getReplacedComparatorSequence();
				for(int i = 0; i < internal.size(); i++) {
					try {
						tree.put(internal.get(i), index);
					}
					catch(IllegalArgumentException e) {
						System.out.println(internal.get(i));
						System.exit(0);
					}
					index++;
				}
			}
		}
		Set<String> candidatePatterns = tree.searchMatchingSuffix(regex);
		// Patterns are only kept if their frequency in the collection is more
		// than an empirically determined number beta

		double total = candidatePatterns.size();
		double counter = 0;
		int steps = (int) total/10;
		for(String candidate : candidatePatterns) {
			if(counter % steps == 0 || counter == total - 1) {
				int percent = (int) (counter/(total-1)*100);
				System.out.print(percent + "% ");
			}
			counter++;
			SequentialPattern lex = new LexicalSequence(candidate);
			//Iterates through and creates twice as many patterns but with the #end tag removed to be able
			//to match middle of sentence
			String mod = candidate.replace(" #end", "");
			SequentialPattern lex1 = new LexicalSequence(mod);
			if(isFrequent(lex, questions, beta)) {
				lexicalPatterns.add(lex);
			}
			if(isFrequent(lex1, questions, beta)) {
				lexicalPatterns.add(lex1);
			}
		}
		return lexicalPatterns;
	}

	/**
	 * In some cases, a pattern can be too general. For example, although, a
	 * question "ipod or zune" is comparative, the pattern "<$C or $C> is too
	 * general, and there can be many noncomparative questions matching the
	 * pattern, for instance "true or false?". Fir this reason, we perform
	 * pattern specialization by adding POS tags to all comparator slots. For
	 * example, from the lexical pattern, "<$C or $C>" and the question "ipod or
	 * zune", "<$C/NN or $C/NN> will be produced as a specialized pattern.
	 * 
	 * @param lexicalPatterns
	 *            The lexical patterns to be specialized
	 * @param generalPatterns
	 *            The general patterns to be generalized
	 * @return A set of specialized items generated from lexical and general
	 *         patterns.
	 */
	public static Set<SequentialPattern> generateSpecializedPatterns(
			Set<SequentialPattern> lexicalPatterns, Set<SequentialPattern> generalPatterns) {
		String regex = "(^|.*?\\s)\\$c.*?\\s\\$c[^A-Za-z0-9_$].*?$";
		List<SequentialPattern> combinedPatterns = new ArrayList<SequentialPattern>(lexicalPatterns);
		combinedPatterns.addAll(generalPatterns);
		Set<SequentialPattern> specializedPatterns = new HashSet<SequentialPattern>();
		double total = combinedPatterns.size();
		double counter = 0;
		int steps = (int) total/10;
		for (int i = 0; i < combinedPatterns.size(); i++) {
			if(counter % steps == 0 || counter == total - 1) {
				int percent = (int) (counter/(total-1)*100);
				System.out.print(percent + "% ");
			}
			counter++;
			SequentialPattern pattern = combinedPatterns.get(i);
			List<List<CompTaggedWord>> tokens = pattern.getTaggedWords();
			List<CompTaggedWord> list = new ArrayList<CompTaggedWord>();
			for(List<CompTaggedWord> innerList : tokens) {
				list.addAll(innerList);
			}
			if(list.toString().matches(regex)) {
				StringBuilder sb = new StringBuilder();
				for(CompTaggedWord tag : list) {
					if(tag.value().equals("$c")) {
						sb.append(tag.toString());
					}
					else {
						sb.append(tag.value());
					}
					sb.append(" ");
				}
				String sequence = PTBTokenizer.ptb2Text(sb.toString());
				SequentialPattern seq = new SpecializedSequence(sequence);
				specializedPatterns.add(seq);
			}

		}
		return specializedPatterns;
	}

	/**
	 * A pattern is only kept if it's frequency in the collection <tt>questionSet</tt>
	 * exceeds a threshold limit <tt>beta</tt>.
	 * @param pattern The pattern that will be checked with its frequency
	 * @param questionSet The set of questions that the pattern will match against
	 * @param beta The threshold frequency for the pattern
	 * @return true if the pattern exceeds the threshold, else false.
	 */
	private static boolean isFrequent(SequentialPattern pattern, Set<Sequence> questionSet, int beta) {
		int counter = 0;
		for(Sequence question : questionSet) {
			if(question.matches(pattern)) {
				counter++;
			}
		}
		return counter > beta;
	}

	/**
	 * Mines reliable lexical, generalized and specialized patterns from comparative questions.
	 * Given a set of comparative questions, <tt>comparativeQuestionSet</tt> lexical,
	 * generalized and specialized patterns are generated. These are then evaluated together
	 * with the reliable <tt>pairs</tt> that has been extracted in previous iterations and
	 * with the entire question repository <tt>questions</tt>.
	 * @param pairs Reliable pairs extracted in previous iterations
	 * @param comparativeQuestionSet Questions that has been identified as comparative
	 * @param questions All questions in the question repository
	 * @return
	 */
	@SuppressWarnings("static-access")
	public static Set<SequentialPattern> mineGoodPatterns(
			Set<Pair<CompTaggedWord, CompTaggedWord>> pairs,
			Set<Sequence> comparativeQuestionSet,
			List<Sequence> questions) {

		Set<SequentialPattern> reliableIEPs = new HashSet<SequentialPattern>();

		Timing t = new Timing();
		t.startDoing("Generating lex patterns");
		Set<SequentialPattern> lexicalPatterns = generateLexicalPatterns(comparativeQuestionSet);
		System.out.print("Size: " + lexicalPatterns.size() + " ");
		t.done();

		t = new Timing();
		t.startDoing("Generating gen patterns");
		Set<SequentialPattern> generalizedPatterns = generateGeneralizedPatterns(lexicalPatterns);
		System.out.print("Size: " + generalizedPatterns.size() + " ");
		t.done();

		t = new Timing();
		t.startDoing("Generating spec patterns");
		Set<SequentialPattern> specializedPatterns = generateSpecializedPatterns(
				lexicalPatterns, generalizedPatterns);
		System.out.print("Size: " + specializedPatterns.size() + " ");
		t.done();

		Set<SequentialPattern> allPatterns = new HashSet<SequentialPattern>(lexicalPatterns);
		allPatterns.addAll(generalizedPatterns);
		allPatterns.addAll(specializedPatterns);
		System.out.println("Total no. of patterns " + allPatterns.size());

		PatternEvaluation eval = new PatternEvaluation(pairs, allPatterns, questions);
		t = new Timing();
		t.startDoing("Calculating reliability");
		double total = allPatterns.size();
		int steps = (int) total/10;
		boolean is25 = false;
		long min15 = 900000;
		long min25 = 1500000;
		for(int counter = 0; counter < total; counter++) {

			if(counter % steps == 0 || counter == total - 1) {
				int percent = (int) (counter/(total-1) *100);
				System.out.print(percent + "% ");
			}
			long elapsed = t.report();

			//if more than 15 minutes has elapsed since starting the timer
			if(elapsed > min15 && !is25) {
				int rand = randomSampling(1, 100);
				if(counter + rand >= total) {
					counter = (int) total - 2;
				}
				else {
					counter += rand;
				}
			}
			//if more than 25 minutes has elapsed since starting the timer
			if(elapsed > min25) {
				int rand = randomSampling(1, 1000);
				if(counter + rand >= total) {
					counter = (int) total - 1;
				}
				else {
					counter += rand;
				}
				is25 = true;
			}

			if(eval.isReliable(counter)) {
				reliableIEPs.add(eval.get(counter));
			}
		}
		t.done();
		//Do some fancy pattern eval
		return reliableIEPs;
	}

	/**
	 * Generates a random number in the range [<tt>min</tt>, <tt>max</tt>].
	 * @param min The minimum value of the randomly generated number
	 * @param max The maximum value of the randomly generated number
	 * @return A random number in the range [<tt>min</tt>, <tt>max</tt>]
	 */
	public static int randomSampling(int min, int max) {
		return 	min + (int)(Math.random() * ((max - min) + 1));
	}
}
