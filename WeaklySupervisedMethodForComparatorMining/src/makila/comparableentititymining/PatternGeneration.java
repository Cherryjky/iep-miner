package makila.comparableentititymining;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Set;

import makila.comparableentititymining.postagger.StanfordPosTagger;
import makila.comparableentititymining.sequentialpatterns.Sequence;
import makila.comparableentititymining.sequentialpatterns.SequentialPattern;
import makila.comparableentititymining.sequentialpatterns.patterns.GeneralizedSequence;
import makila.comparableentititymining.sequentialpatterns.patterns.LexicalSequence;
import makila.comparableentititymining.sequentialpatterns.patterns.Pattern;

import com.strongczq.SuffixTree;

@SuppressWarnings("unused")
public class PatternGeneration {
	private static String comparator = MiningIndicativeExtractionPatterns.comparator;
	private static double beta = MiningIndicativeExtractionPatterns.beta;

	public static List<String> mineGoodPatterns(List<String> seedComparatorPairs,
			List<String> comparativeQuestionSet) {
		for(String question : comparativeQuestionSet) {
			/*
			 * String surfacePattern = surfaceTextPatternMining(question)
			 */
		}
		List<Pattern> lexicalPatterns = generateLexicalPatterns(comparativeQuestionSet); 
		List<Pattern> generalizedPatterns = generateGeneralizedPatterns(lexicalPatterns);
		List<Pattern> specializedPatterns = generateSpecializedPatterns(lexicalPatterns, generalizedPatterns);

		return null;
	}

	/**
	 * Lexical patterns indicate sequential patterns consisting of only words and
	 * symbols ($C, #start, and "#end"). They are generated by suffix tree algorithm
	 * with two constraints: A patterns should contain more than one $C and its frequency
	 * in collection should be more than an empirically determined number beta.
	 * @param questions The set of questions to generate patterns from
	 * @return A set of lexical patterns
	 */
	public static List<Pattern> generateLexicalPatterns(List<String> questions) {
		List<Pattern> lexicalPatterns = new ArrayList<Pattern>();
		Map<String, Integer> candidatePatterns = new HashMap<String, Integer>();
		for(String question : questions) {
			SuffixTree tree = new SuffixTree(); 
			tree.build(question.toCharArray());
			//Only keep lexical patterns that contains more than one $C
			for(String suffix : tree.getSuffix()) {
				int $C = suffix.indexOf(comparator);
				boolean moreThanOne$C = $C != -1 && suffix.indexOf(comparator, $C + 1) != -1;
				if(moreThanOne$C) {
					if(candidatePatterns.containsKey(suffix)) {
						candidatePatterns.put(suffix, candidatePatterns.get(suffix) + 1);
					}
					else {
						candidatePatterns.put(suffix, 1);
					}
				}
			}
		}
		//Patterns are only kept if their frequency in the collection is more than an empirically determined number beta
		Iterator<Map.Entry<String, Integer>> entries = candidatePatterns.entrySet().iterator();
		while (entries.hasNext()) {
			Map.Entry<String, Integer> entry = entries.next();
			String key = entry.getKey();
			Integer value = entry.getValue();
			if(value <= beta) {
				System.out.println(entries.toString());
				entries.remove();
				//candidatePatterns.remove(key);
			}
		}
		Set<String> keySet = candidatePatterns.keySet();
		for(String key : keySet) {
			Pattern seq = new LexicalSequence(key);
			lexicalPatterns.add(seq);
		}
		return lexicalPatterns;
	}


	/**
	 * A lexical pattern can be too specific. Thus, we generalize lexical patterns
	 * by replacing one or more words/phrases with their POS tags. 2^(n-1) generalized
	 * patterns can be produced from a lexical pattern containing N words excluding $Cs. 
	 * @param patterns A lexical pattern from which generalized patterns can be generated
	 * @return A set of generalized patterns
	 */
	public static List<Pattern> generateGeneralizedPatterns(List<Pattern> patterns) {
		System.out.println("Start generalization");
		List<Pattern> generalizedPatterns = new ArrayList<Pattern>();
		for(Pattern pattern : patterns) {
			List<List<String>> posTags= StanfordPosTagger.getStringTags(pattern.toString());
			List<List<String>> tokenizedWords = StanfordPosTagger.tokenizedString(pattern.toString());
			try {
				if(posTags.size() != tokenizedWords.size()) {
					throw new Exception();
				}
			}
			catch(Exception ex) {
				System.err.println("Tags and token length mismatch. Something is funky...");
			}
			for(int i = 0; i < posTags.size(); i++) {
				List<List<String>> combinations = combinations(tokenizedWords.get(i), posTags.get(i));
				for(List<String> combo : combinations) {
					String string = StanfordPosTagger.unTokenizeString(combo);
					Pattern seq = new GeneralizedSequence(string);
					generalizedPatterns.add(seq);
				}
			}
		}
		System.out.println("Size = " + generalizedPatterns.size() + "\nEnd generalization!");
		return generalizedPatterns;
	}



	/**
	 * In some cases, a pattern can be too general. For example, although, a question 
	 * "ipod or zune" is comparative, the pattern "<$C or $C> is too general, and there 
	 * can be many noncomparative questions matching the pattern, for instance "true or false?".
	 * Fir this reason, we perform pattern specialization by adding POS tags to all
	 * comparator slots. For example, from the lexical pattern, "<$C or $C>" and the question "ipod
	 * or zune", "<$C/NN or $C/NN> will be produced as a specialized pattern. 
	 * @param lexicalPatterns The lexical patterns to be specialized
	 * @param generalPatterns The general patterns to be generalized
	 * @return A set of specialized items generated from lexical and general patterns.
	 */
	public static List<Pattern> generateSpecializedPatterns(List<Pattern> lexicalPatterns, List<Pattern> generalPatterns) {
		List<Pattern> combinedPatterns = new ArrayList<Pattern>(lexicalPatterns);
		combinedPatterns.addAll(generalPatterns);
		for(int i = 0; i < combinedPatterns.size(); i++) {
			Pattern pattern = combinedPatterns.get(i);
			if(pattern.equals(comparator)) {
				String addPos = combinedPatterns.get(i) + "_pos";
				if(pattern.isLexical()) {
					combinedPatterns.set(i, new LexicalSequence(addPos));
				}
				else {
					combinedPatterns.set(i, new GeneralizedSequence(addPos));
				}
			}
		 }
		return combinedPatterns;
	}
	
	/**
	 * Generates all combinations where each element from question is replaced with 
	 * the corresponding element from pos.
	 * @param question Contains the item to be replaced
	 * @param pos Contains the POS tags to replace the items
	 * @return Lists containing all possible combinations with question items replaced with pos.
	 */
	
	private static List<List<String>> combinations(List<String> question, List<String> pos) {
		List<List<String>> replaced = new ArrayList<List<String>>();
		//int max = (int) Math.pow(2, question.size() - 1);
		int log = (int) Math.ceil(Math.log(question.size() + pos.size())/Math.log(2));
		int max = (int) Math.pow(question.size() + pos.size(), 3);
		int numBits = question.size();
		for(int i = 1; i <= max; i++) {
			String[] questionArray = question.toArray(new String[question.size()]);
			String format = "%" + question.size() + "s";
			String bin = String.format(format, Integer.toBinaryString(i)).replace(' ', '0');
			char[] binary = bin.toCharArray();
			if(binary.length > question.size()) {
				break;
			}
			for(int j = 0; j < binary.length; j++) {
				if(binary[j] == '1') {
					if(!question.get(j).equals(comparator)) {
						questionArray[j] = pos.get(j);
					}
				}
			}
			replaced.add(Arrays.asList(questionArray));
		}
		return replaced;
	}
		
	
}



